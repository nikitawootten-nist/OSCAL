<?xml version="1.0" encoding="UTF-8"?>
<!-- autogenerated 2022-04-26T17:20:58.3482225-04:00 following model in example-set.xspec-->
<?xml-model href="lib/xspec-test-dev.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-stylesheet type="text/css" href="lib/xspec-oxygen.css"?>
<?specification profile-resolution-specml-102plus.xml?>
<x:description xmlns:o="http://csrc.nist.gov/ns/oscal/1.0"
               xmlns:opr="http://csrc.nist.gov/ns/oscal/profile-resolution"
               xmlns:x="http://www.jenitennison.com/xslt/xspec"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"
               stylesheet="../../utils/util/resolver-pipeline/oscal-profile-RESOLVE.xsl"
               run-as="external">
   <x:helper stylesheet="lib/oscal-profile-test-helper.xsl"/>
   <x:scenario label="5 Phases of Profile Processing | It is strongly RECOMMENDED that implementations execute the following steps in the order that they are provided here (import, merge, modify)."
               pending="[dev]">
      <x:scenario label="Example TBD - PENDING test design" pending="test design"/>
   </x:scenario>
   <x:scenario label="6.1.1 Import URI Resolution | Tools MUST resolve URIs by following Section 5 of RFC3986, with the exception of URI Fragments (URIs that start with &#34;#&#34;). URI Fragments MUST instead be resolved as defined in [Section internalref].">
      <x:scenario label="Example req-include-all-asis.xml - relative URI"><?requirement req-uri-resolve ?>
         <x:context href="requirement-tests/req-include-all-asis.xml"/>
         <x:expect label="Resolution of req-include-all-asis.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-all-asis_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.2 Import Resource Acquisition | Tools MUST acquire resources at the resolved URI by following Section 5 of RFC3986, with the exception of URI Fragments (URIs that start with &#34;#&#34;). URI Fragments MUST instead be acquired as defined in [Section internalref].">
      <x:scenario label="Example req-import-by-resource.xml - via internal reference to&#xA;              resource/rlink"><?requirement req-uri-aquire ?>
         <x:context href="requirement-tests/req-import-by-resource.xml"/>
         <x:expect label="Resolution of req-import-by-resource.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-import-by-resource_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.2 Import Resource Acquisition | For the purposes of resolving URIs using the above specification, the Base URI MUST be considered to be the absolute URI of the containing profile.">
      <x:scenario label="Example req-include-all-asis.xml - URI base corresponds to document URI"><?requirement req-uri-base ?>
         <x:context href="requirement-tests/req-include-all-asis.xml"/>
         <x:expect label="Resolution of req-include-all-asis.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-all-asis_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.2 Import Resource Acquisition | In the case that acquiring a resource fails, the tool MUST cease processing and provide an error. In order to ensure profile resolution results in the same catalog regardless of which tool resolves it, all imports must successfully resolve. While this may cause inconvenience if resources are frequently not available, it ensures interoperability.">
      <x:scenario label="Example req-missing-resource.xml - PENDING rebase over latest from galtm missing resource"
                  pending="rebase over latest from galtm missing resource"><?requirement req-uri-error ?>
         <x:context href="requirement-tests/req-missing-resource.xml"/>
         <x:expect label="Resolution of req-missing-resource.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-missing-resource_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.3 Internal References | In the context of the Import Phase, internal references will only appear as a reference to a profile or catalog that is in the resources section of the source. When tools encounter such a reference, they MUST locate the object in resources with the matching UUID value, and resolve the resource. By OSCAL model requirements, a given resource can have zero to many rlink objects and zero to one base64 objects; however, it must have at least one of the two present. Tools can assume that any of these each resolves to the same underlying OSCAL object, although potentially in different serialization formats. For deterministic resolution of these backmatter OSCAL objects, tools need to adhere to the following requirements:">
      <x:scenario label="Example req-import-by-resource.xml - "><?requirement req-internal ?>
         <x:context href="requirement-tests/req-import-by-resource.xml"/>
         <x:expect label="Resolution of req-import-by-resource.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-import-by-resource_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.3 Internal References | Tools MAY use any of the rlink or base64 objects present in the resource."
               pending="[dev]">
      <x:scenario label="Example TBD - PENDING test design (support for either/both base64&#xA;                  and rlink)"
                  pending="test design (support for either/both base64&#xA;                  and rlink)"/>
   </x:scenario>
   <x:scenario label="6.1.3 Internal References | Tools MAY verify that each above objects resolves to the same underlying OSCAL object. If there are OSCAL Model content differences between the resolved objects, the tool SHOULD provide a warning."
               pending="[dev]">
      <x:scenario label="Example TBD - PENDING test design (correspondence of base64 and&#xA;                  rlink-nominated objects)"
                  pending="test design (correspondence of base64 and&#xA;                  rlink-nominated objects)"/>
   </x:scenario>
   <x:scenario label="6.1.3 Internal References | When a rlink is encountered and is to be resolved, it MUST be resolved by using a HTTP request to retrieve a byte stream."
               pending="[dev]">
      <x:scenario label="Example TBD - PENDING test design (retrieval)"
                  pending="test design (retrieval)"/>
   </x:scenario>
   <x:scenario label="6.1.3 Internal References | When a base64 is encountered and is to be resolved, it MUST be considered a Byte Stream."
               pending="[dev]">
      <x:scenario label="Example TBD - PENDING test design (base64 integrity)"
                  pending="test design (base64 integrity)"/>
   </x:scenario>
   <x:scenario label="6.1.3 Internal References | Regardless of its source, the Byte Stream MUST be decoded based on the algorithm defined in Section 4 RFC 4648."
               pending="[dev]">
      <x:scenario label="Example TBD - PENDING test design (base64&#xA;                integrity)"
                  pending="test design (base64&#xA;                integrity)"/>
   </x:scenario>
   <x:scenario label="6.1.3 Internal References | If the object fetched cannot be found or is not a valid OSCAL object, the tool MUST cease processing and provide an error.">
      <x:scenario label="Example req-missing-resource.xml - PENDING rebase over latest from galtm"
                  pending="rebase over latest from galtm"><?requirement req-internal-error ?>
         <x:context href="requirement-tests/req-missing-resource.xml"/>
         <x:expect label="Resolution of req-missing-resource.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-missing-resource_RESOLVED.xml"/>
      </x:scenario>
      <x:scenario label="Example req-broken-import.xml - PENDING rebase over latest from galtm"
                  pending="rebase over latest from galtm"><?requirement req-internal-error ?>
         <x:context href="requirement-tests/req-broken-import.xml"/>
         <x:expect label="Resolution of req-broken-import.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-broken-import_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.4 Resolving Imports of Profiles | If the resource acquired is an OSCAL Profile, the tool MUST apply this specification to resolve it, then continue processing having imported the resulting catalog.">
      <x:scenario label="Example req-chained-all-asis.xml - PENDING chained profiles"
                  pending="chained profiles"><?requirement req-circular-resolve ?>
         <x:context href="requirement-tests/req-chained-all-asis.xml"/>
         <x:expect label="Resolution of req-chained-all-asis.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-chained-all-asis_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.4 Resolving Imports of Profiles | When a profile imports a profile, the subordinate profile SHOULD be resolved first into a catalog using this specification, before it is imported.">
      <x:scenario label="Example req-chained-all-asis.xml - PENDING chained profiles"
                  pending="chained profiles"><?requirement req-resolve-profile ?>
         <x:context href="requirement-tests/req-chained-all-asis.xml"/>
         <x:expect label="Resolution of req-chained-all-asis.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-chained-all-asis_RESOLVED.xml"/>
      </x:scenario>
      <x:scenario label="Example req-chained-deepA.xml - PENDING [bug repair] chained profile&#xA;              merged with controls from its own source catalog"
                  pending="[bug repair] chained profile&#xA;              merged with controls from its own source catalog"><?requirement req-resolve-profile ?>
         <x:context href="requirement-tests/req-chained-deepA.xml"/>
         <x:expect label="Resolution of req-chained-deepA.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-chained-deepA_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.4 Resolving Imports of Profiles | If a processor encounters a circular import as described above (self-imports are inherently circular), the processor MUST cease processing and generate an error.">
      <x:scenario label="Example req-circular_import.xml - PENDING circular import detection"
                  pending="circular import detection"><?requirement req-circular-error ?>
         <x:context href="requirement-tests/req-circular_import.xml"/>
         <x:expect label="Resolution of req-circular_import.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-circular_import_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.5 Multiple imports | Note that this occurs even if the same catalog is imported multiple times: each distinct import collects controls into a separate selection">
      <x:scenario label="Example req-chained-deepA.xml - PENDING&#xA;              chained profiles"
                  pending="chained profiles"><?requirement rq-mulitple-imports ?>
         <x:context href="requirement-tests/req-chained-deepA.xml"/>
         <x:expect label="Resolution of req-chained-deepA.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-chained-deepA_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.1.5 Multiple imports | The control inclusions are combined and collapsed in the next phase of processing">
      <x:scenario label="Example req-chained-deepA.xml - PENDING&#xA;              chained profiles"
                  pending="chained profiles"><?requirement rq-multiple-merge ?>
         <x:context href="requirement-tests/req-chained-deepA.xml"/>
         <x:expect label="Resolution of req-chained-deepA.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-chained-deepA_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.1 include-all | When an import provides the include-all directive, ALL controls and groups in the referenced document (including nested controls) MUST be included.">
      <x:scenario label="Example req-include-all-asis.xml - "><?requirement req-include-all ?>
         <x:context href="requirement-tests/req-include-all-asis.xml"/>
         <x:expect label="Resolution of req-include-all-asis.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-all-asis_RESOLVED.xml"/>
      </x:scenario>
      <x:scenario label="Example req-include-all-flat.xml - "><?requirement req-include-all ?>
         <x:context href="requirement-tests/req-include-all-flat.xml"/>
         <x:expect label="Resolution of req-include-all-flat.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-all-flat_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.2 include-controls plus with-id | When an import provides the include-controls directive, with a with-id child, all controls in the referenced document whose id match one of the listed id values MUST be included.">
      <x:scenario label="Example req-include-by-id.xml - "><?requirement req-include-by-id ?>
         <x:context href="requirement-tests/req-include-by-id.xml"/>
         <x:expect label="Resolution of req-include-by-id.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-by-id_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.3 include-controls plus matching | When an import provides the include-controls directive, with a matching child, all controls in the referenced document whose id matches one of the listed pattern values (Glob matching) MUST be included.">
      <x:scenario label="Example req-include-by-match.xml - "><?requirement req-include-by-match ?>
         <x:context href="requirement-tests/req-include-by-match.xml"/>
         <x:expect label="Resolution of req-include-by-match.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-by-match_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.3 include-controls plus matching | If a matching object is provided with no pattern, it MUST be treated as matching nothing. While not providing a pattern is technically valid, resolution tool implementers should be aware that it is generally undesirable, and warnings or notices to the user may be appropriate.">
      <x:scenario label="Example req-include-by-match-empty.xml - "><?requirement req-include-by-match-empty ?>
         <x:context href="requirement-tests/req-include-by-match-empty.xml"/>
         <x:expect label="Resolution of req-include-by-match-empty.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-by-match-empty_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.4.1 with-child-controls | A with-child-controls: yes directive on an include-controls indicates that all descendant controls of the included control MUST also be included.">
      <x:scenario label="Example req-include-by-id.xml - "><?requirement req-with-child-controls-yes ?>
         <x:context href="requirement-tests/req-include-by-id.xml"/>
         <x:expect label="Resolution of req-include-by-id.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-by-id_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.4.1 with-child-controls | A with-child-controls: no directive on an include-controls indicates that ONLY the matching control is included, any descendant children MUST NOT be included.">
      <x:scenario label="Example req-with-child-controls-no.xml - "><?requirement req-with-child-controls-no ?>
         <x:context href="requirement-tests/req-with-child-controls-no.xml"/>
         <x:expect label="Resolution of req-with-child-controls-no.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-with-child-controls-no_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.4.1 with-child-controls | If no with-child-controls is provided, the processor MUST consider the directive as being equivalent to one having with-child-controls:no.">
      <x:scenario label="Example req-with-child-controls-none.xml - "><?requirement req-with-child-controls-none ?>
         <x:context href="requirement-tests/req-with-child-controls-none.xml"/>
         <x:expect label="Resolution of req-with-child-controls-none.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-with-child-controls-none_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.4.2 with-parent-controls | A with-parent-controls: yes directive on an include-controls indicates that all parent controls of the included control MUST also be included.">
      <x:scenario label="Example req-with-parent-controls-yes1.xml - PR&#xA;                https://github.com/usnistgov/OSCAL/pull/1207"><?requirement req-with-parent-controls-yes ?>
         <x:context href="requirement-tests/req-with-parent-controls-yes1.xml"/>
         <x:expect label="Resolution of req-with-parent-controls-yes1.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-with-parent-controls-yes1_RESOLVED.xml"/>
      </x:scenario>
      <x:scenario label="Example req-with-parent-controls-yes2.xml - PR&#xA;                https://github.com/usnistgov/OSCAL/pull/1207"><?requirement req-with-parent-controls-yes ?>
         <x:context href="requirement-tests/req-with-parent-controls-yes2.xml"/>
         <x:expect label="Resolution of req-with-parent-controls-yes2.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-with-parent-controls-yes2_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.4.2 with-parent-controls | A with-parent-controls: no directive on an include-controls indicates that ONLY the matching control is included, any parent MUST NOT be included.">
      <x:scenario label="Example req-with-parent-controls-no1.xml - PENDING PR&#xA;                https://github.com/usnistgov/OSCAL/pull/1207"
                  pending="PR&#xA;                https://github.com/usnistgov/OSCAL/pull/1207"><?requirement req-with-parent-controls-no ?>
         <x:context href="requirement-tests/req-with-parent-controls-no1.xml"/>
         <x:expect label="Resolution of req-with-parent-controls-no1.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-with-parent-controls-no1_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.4.2 with-parent-controls | If no with-parent-controls is provided, the processor MUST consider the directive as being equivalent to one having with-parent-controls:yes."
               pending="[dev]">
      <x:scenario label="Example TBD - PENDING PR&#xA;                https://github.com/usnistgov/OSCAL/pull/1207"
                  pending="PR&#xA;                https://github.com/usnistgov/OSCAL/pull/1207"/>
   </x:scenario>
   <x:scenario label="6.2.5 exclude-controls | Any control designated to be both included and excluded, MUST be excluded. This holds irrespective of the specificity of the selection for inclusion or exclusion.">
      <x:scenario label="Example req-include-exclude1.xml - "><?requirement req-exclude ?>
         <x:context href="requirement-tests/req-include-exclude1.xml"/>
         <x:expect label="Resolution of req-include-exclude1.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-exclude1_RESOLVED.xml"/>
      </x:scenario>
      <x:scenario label="Example req-include-exclude2.xml - "><?requirement req-exclude ?>
         <x:context href="requirement-tests/req-include-exclude2.xml"/>
         <x:expect label="Resolution of req-include-exclude2.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-exclude2_RESOLVED.xml"/>
      </x:scenario>
      <x:scenario label="Example req-include-exclude3.xml - "><?requirement req-exclude ?>
         <x:context href="requirement-tests/req-include-exclude3.xml"/>
         <x:expect label="Resolution of req-include-exclude3.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-exclude3_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.5 exclude-controls | When exclude-controls has at least one with-ids or matching directive, the processor MUST follow the same rules as defined in the relevant sections above for these directives, but exclude instead of include any controls. All optional features (with-child-controls, etc.) also apply to exclusion directives.">
      <x:scenario label="Example req-include-exclude4.xml - "><?requirement req-exclude-additional ?>
         <x:context href="requirement-tests/req-include-exclude4.xml"/>
         <x:expect label="Resolution of req-include-exclude4.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-exclude4_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.6 Redundant Inclusions and Exclusions | A given import may have any number of inclusion statements and any number of exclusion statements. Their effect is cumulative; any control that is included (or excluded) more than once MUST be considered to be included (or excluded) only once. In other words, a given control being included or excluded more than once has no effect. Exclusion still takes priority over inclusion (see above).">
      <x:scenario label="Example req-include-exclude4.xml - "><?requirement req-redundant ?>
         <x:context href="requirement-tests/req-include-exclude4.xml"/>
         <x:expect label="Resolution of req-include-exclude4.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-exclude4_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="6.2.7 Handling Params | All loose params from both imported documents and the profile source MUST be included. These params will be kept in the final output if the document contains any references to them, and discarded otherwise. See [Section cleanup]."
               pending="[dev]"/>
   <x:scenario label="7 Merge Phase | It is RECOMMENDED that tools apply the &#34;combine&#34; directive to the intermediate generated by the Import phase first, then apply the &#34;structuring&#34; directive."
               pending="[dev]">
      <x:scenario label="Example TBD - PENDING is this testable?"
                  pending="is this testable?"/>
   </x:scenario>
   <x:scenario label="7.1 The &#34;combine&#34; Directive | Note that &#34;merge: combine&#34; is deprecated, and MUST be considered undefined behavior when encountered."
               pending="[dev]">
      <x:scenario label="Example TBD - PENDING specification" pending="specification"/>
   </x:scenario>
   <x:scenario label="7.1.1 No Combine Directive | If no merge directive is given in the profile, or if a merge is given without a combine, merge conflicts MUST be treated as if method: keep was given.">
      <x:scenario label="Example keep-everything-twice.xml - "><?requirement req-merge-none ?>
         <x:context href="requirement-tests/keep-everything-twice.xml"/>
         <x:expect label="Resolution of keep-everything-twice.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/keep-everything-twice_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="7.1.2 method:keep | When a merge is indicated by method:keep, or when no merge directive is given, the keepcombination rule is used. Any control with the same distinctive ID [Section id]MUST NOT not merged. (They are kept.)"
               pending="[dev]"/>
   <x:scenario label="7.1.2 method:keep | Processors SHOULD provide a warning under the merge:keep directive when duplicate controls are detected."
               pending="[dev]"/>
   <x:scenario label="7.1.2 method:keep | The processor MAY throw an error and cease processing (short-circuiting a certain future error) when duplicate controls are detected under the merge:keep directive."
               pending="[dev]"/>
   <x:scenario label="7.1.3 method:use-first | When the &#34;use-first&#34;combination rule is applied, and controls that share a distinctive ID are found, the first control encountered MUST be kept, the rest MUST be discarded. &#34;First&#34; MUST be determined by a top-down, depth-first traversal of the source profile's import hierarchy."
               pending="[dev]"/>
   <x:scenario label="7.2 The &#34;structuring&#34; Directive | Optionally, one of three &#34;structuring&#34; directives can be included as a child of merge: flat, as-isand custom. When one of these appears, it is the selected structuring directive. If more than one appears, processors MUST generate an error and cease processing."
               pending="[dev]"/>
   <x:scenario label="7.2.1 No Structuring Directive | If no merge directive is given in the profile, or if a merge is given without a structuring directive, structuring the output MUST be treated as if the structuring directive flat was given. For example, a profile with no merge directive:">
      <x:scenario label="Example req-include-all-flat.xml - "><?requirement req-structure-none ?>
         <x:context href="requirement-tests/req-include-all-flat.xml"/>
         <x:expect label="Resolution of req-include-all-flat.xml"
                   select="opr:scrub(.)"
                   href="requirement-tests/output-expected/req-include-all-flat_RESOLVED.xml"/>
      </x:scenario>
   </x:scenario>
   <x:scenario label="7.2.2 &#34;flat&#34; | Profiles with the &#34;flat&#34; merge directive MUST be resolved as unstructured catalogs, with no grouping or nesting of controls."
               pending="[dev]"/>
   <x:scenario label="7.2.2 &#34;flat&#34; | Unstructured catalog output MUST be produced by adhering to the following requirements:"
               pending="[dev]"/>
   <x:scenario label="7.2.2 &#34;flat&#34; | All included controls are output to the target as a flat list directly under &#34;catalog&#34;."
               pending="[dev]"/>
   <x:scenario label="7.2.2 &#34;flat&#34; | Any included &#34;loose params&#34; are output to the target as a flat list directly under &#34;catalog&#34;."
               pending="[dev]"/>
   <x:scenario label="7.2.2 &#34;flat&#34; | Any groups are discarded." pending="[dev]"/>
   <x:scenario label="7.2.3 as-is | Processors MUST handle the as-is directive by adhering to the following requirements:"
               pending="[dev]"/>
   <x:scenario label="7.2.3 as-is | All included controls are output to the target, keeping the structure of the groups and nested controls. Any group that holds an included control MUST appear in the output with all of its non-control children intact. If an included control has a parent control that was not included, that control's output location is &#34;up-leveled&#34;, or made equal to the non-included parent. This applies recursively until the control is directly under either &#34;catalog&#34; or another included control."
               pending="[dev]"/>
   <x:scenario label="7.2.3 as-is | Any included &#34;loose params&#34; are output to the target as a flat list directly under &#34;catalog&#34;."
               pending="[dev]"/>
   <x:scenario label="7.2.4.1 Creating Custom Groups | A groupobject given under custom MUST result in a group with the exact same content (excluding insert-controls) in the target catalog."
               pending="[dev]"/>
   <x:scenario label="7.2.4.1 Creating Custom Groups | If the ID of the group matches the ID of a group that has been included during the import phase, all contents inside the group, including title, param, prop and part objects MUST be copied into the target, appearing in the same order as in the source."
               pending="[dev]"/>
   <x:scenario label="7.2.4.2 Inserting Controls | When processing the control selection of a custom element, the behavior defined in this section MUST be followed to generate the output."
               pending="[dev]"/>
   <x:scenario label="7.2.4.2 Inserting Controls | In the case that a control selection matches none of the included controls, it MUST be ignored."
               pending="[dev]"/>
   <x:scenario label="7.2.4.2 Inserting Controls | In the case that a control selection matches none of the included controls, a warning SHOULD be provided."
               pending="[dev]"/>
   <x:scenario label="8.1 Setting Parameters | If no such parameter is found, a warning SHOULD be issued."
               pending="[dev]"/>
   <x:scenario label="8.1 Setting Parameters | If no such parameter is found, processing MUST still continue."
               pending="[dev]"/>
   <x:scenario label="8.1 Setting Parameters | For the following objects inside the source: class, depends-on, label, usage, values, select; the object MUST be copied into the target from the source, first removing any existing objects with the same name."
               pending="[dev]"/>
   <x:scenario label="8.1 Setting Parameters | For the following objects inside the source: props, links, constraints, guidelines; the contents of the object MUST be added to the contents of the target object of the same name. If no such object exists in the target, it is created."
               pending="[dev]"/>
   <x:scenario label="8.1 Setting Parameters | For the following objects inside the source: prop, link; the object MUST be copied into the target from the source, first removing any existing objects with the same distinctive ID. ([Section id])."
               pending="[dev]"/>
   <x:scenario label="8.1 Setting Parameters | If more than one set-parameter directive is given for the same parameter, all MUST BE applied, in the sequence given in the profile."
               pending="[dev]"/>
   <x:scenario label="8.2.1.1 Implicit binding | An add directive with no by-id child MUST be considered an implicit binding, and will apply to the control as a whole."
               pending="[dev]"/>
   <x:scenario label="8.2.1.1 Implicit binding | The contents of an implicitly bound add directive MUST be added to the control contents in the target, either after its title when position is starting, or at the end if its position is ending, or if no valid position is given."
               pending="[dev]"/>
   <x:scenario label="8.2.1.1 Implicit binding | When an add directive is implicitly bound, the position values before and after MUST be treated like starting and ending, respectively."
               pending="[dev]"/>
   <x:scenario label="8.2.1.1 Implicit binding | After processing an implicitly bound add directive, the control contents MUST be sorted to appear in the required order: a new prop appears after any prop already in the control, when position is ending, or not given, or before any prop in the control when position is starting."
               pending="[dev]"/>
   <x:scenario label="8.2.1.2 Explicit binding | An add directive with a by-id child MUST be considered an explicit binding, and applies to only a single object inside the control."
               pending="[dev]"/>
   <x:scenario label="8.2.1.2 Explicit binding | When an add directive is explicitly bound, the value of the by-id child MUST correspond to the value of an id on an object inside the control, and not the control itself."
               pending="[dev]"/>
   <x:scenario label="8.2.1.2 Explicit binding | If by-id does not correspond to such a value, the add directive MUST be considered inoperative and ignored."
               pending="[dev]"/>
   <x:scenario label="8.2.1.2 Explicit binding | An inoperative add directive MAY result in a warning."
               pending="[dev]"/>
   <x:scenario label="8.2.1.2 Explicit binding | When position has a value of startingor ending, the contents of the source MUST be added inside the target, either at the start or end of its contents, respectively."
               pending="[dev]"/>
   <x:scenario label="8.2.1.2 Explicit binding | When position has a value of before or after, the contents of the source MUST be added outside the target, either directly before or after it, respectively."
               pending="[dev]"/>
   <x:scenario label="8.2.1.3 Modifying controls inside controls | Profile resolution tools MUST be able to correctly handle add directives targetting nested controls. This includes directives that target a child control as well as directives that target a parent control and modify the child."
               pending="[dev]"/>
   <x:scenario label="8.2.2 Removing contents from controls | An object inside the control MUST be removed from the output if and only if it meets all of the criteria given by the child objects of the remove directive."
               pending="[dev]"/>
   <x:scenario label="8.2.2 Removing contents from controls | The remove directive criteria by-id MUST match an object if and only if its value is identical to the id value of that object."
               pending="[dev]"/>
   <x:scenario label="8.2.2 Removing contents from controls | The remove directive criteria name-ref MUST match an object if and only if its value is identical to the value of that object's name child."
               pending="[dev]"/>
   <x:scenario label="8.2.2 Removing contents from controls | The remove directive criteria ns-ref MUST match an object if and only if its value is identical to the value of that object's ns child."
               pending="[dev]"/>
   <x:scenario label="8.2.2 Removing contents from controls | The remove directive criteria class-ref MUST match an object if and only if its value is identical to the value of that object's class child."
               pending="[dev]"/>
   <x:scenario label="8.2.2 Removing contents from controls | The remove directive criteria item-name MUST match an object if and only if its value is identical to the value of that object's serialized name."
               pending="[dev]"/>
   <x:scenario label="8.2.2 Removing contents from controls | In serialization formats that use arrays of objects in the OSCAL model, an object's name MUST be referenced as singular form of its containing parent array."
               pending="[dev]"/>
   <x:scenario label="9.1 Backmatter Resolution | The output's backmatter MUST be generated by copying in each resource object from the backmatters of the imported catalogs/profiles in top-to-bottom order, then by copying in each resource object from the backmatter of the source profile itself. These objects MUST be processed in the order they are defined in each respective document."
               pending="[dev]"/>
   <x:scenario label="9.1 Backmatter Resolution | If a given resource has the same uuid as a resource that has already been added, the previous resource MUST be removed, and the more recent one added, unless superseded by other requirements."
               pending="[dev]"/>
   <x:scenario label="9.1 Backmatter Resolution | A resource with a child prop of name:keep and value:always MUST NOT be replaced by the addition of another resource, unless the new resource also has a child prop of name:keep and value:always."
               pending="[dev]"/>
   <x:scenario label="9.1 Backmatter Resolution | Tools MAY check for pruning conditions [Section cleanup] as resources are added as long as the final result is the same as if the pruning had taken place at the end of all resource addition."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | The output catalog's metadata MUST have a unique top-level UUID (metadata:uuid). This UUID MAY be generated as seen fit by the tool, as long as it is reasonable to assume it is globally unique. It is RECOMMENDED that tools use a Version 4 UUID as specified in Section 4 of RFC 4122."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | The value of metadata:version in the target MUST be set with a string that identifies the version of that document."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | The metadata:version SHOULD be used to track updates to this specific output document."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | The value of metadata:oscal-version in the target MUST be set with a string that identifies the version of OSCAL used by this tool to resolve the profile (ex. 1.0.0). This value MUST be determined by compiling the oscal-versions from each imported document and the source profile, and taking the most recent minor version. If this version is more recent than what the resolution tool is using, then the value of oscal-version MUST be the version that the tool used internally."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | If any of the above OSCAL versions (imported document versions, source profile version, tool version) are of a different major version (the first digit differs), the tool SHOULD provide an error and cease processing."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | The value of metadata:last-modified in the target MUST be set with a valid timestamp. This value SHOULD represent the time that resolution occurred."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | A child prop object with name:source-profile MUST be created. The value object of this prop SHOULD be set with a valid URI that points to the profile that resulted in this catalog."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | If there are privacy or security concerns, the value object of this prop MAY be set to anything, in which case the simple existence of the source-profile property indicates that this is a resolved profile."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | A child prop object with name:resolution-tool SHOULD be created. The value object of this prop in the target SHOULD be set with a string that represents the tool that was used to resolve this catalog."
               pending="[dev]"/>
   <x:scenario label="9.2 Metadata Resolution | For any metadata:roles or metadata:parties that exist in the source catalogs, if they have a prop child with name:keep and value:always, they are to be copied as is into the output metadata."
               pending="[dev]"/>
   <x:scenario label="9.3 Pruning and Ordering | The processor SHOULD prune the resulting output catalog by removing unused objects."
               pending="[dev]"/>
   <x:scenario label="9.3 Pruning and Ordering | Any object that has a child prop with a name of &#34;keep&#34; and a value of &#34;always&#34; MUST NOT be pruned."
               pending="[dev]"/>
   <x:scenario label="9.3 Pruning and Ordering | If an object was explicitly included in the [Section select-phase], it MUST NOT be pruned."
               pending="[dev]"/>
   <x:scenario label="9.3 Pruning and Ordering | If an object was referenced in a custom section of the source profile, it MUST NOT be pruned."
               pending="[dev]"/>
   <x:scenario label="9.3 Pruning and Ordering | If an object was referenced in the modify section of the source profile, it MUST NOT be pruned. Any objects removed in that section are still removed."
               pending="[dev]"/>
   <x:scenario label="9.3 Pruning and Ordering | If the object appears in a reference anywhere in the final result catalog, except in other objects that also meet all other pruning criteria, it MUST NOT be removed. A reference to a given object exists if #{distinctiveID} appears anywhere, where {distinctiveID} is the distinctive ID of the object [Section id]."
               pending="[dev]"/>
   <x:scenario label="9.3 Pruning and Ordering | Tools MUST reorder the output catalog into canonical order [Section order], except where this specification provides different ordering requirements."
               pending="[dev]"/>
   <x:scenario label="10.1 Distinct ID of Objects | For the objects control, param, and group, distinctiveness MUST be determined by the value of the &#34;id&#34; child object."
               pending="[dev]"/>
   <x:scenario label="10.1 Distinct ID of Objects | For the object resource, distinctiveness MUST be determined by the value of the &#34;uuid&#34; [Section target-back-matter]."
               pending="[dev]"/>
   <x:scenario label="10.2 Dealing with Multiple Formats | Profile Resolution tools SHOULD be able to handle source profiles, imported catalogs, and imported profiles that are serialized in XML, JSON, or YAML."
               pending="[dev]"/>
   <x:scenario label="10.2 Dealing with Multiple Formats | A different serialization format of any given input MUST NOT result in a differing output catalog."
               pending="[dev]"/>
   <x:scenario label="10.2.1 Requirements and Guidance for XML Output | The final Catalog output, if using XML, MUST be valid as defined by the XML model documentation for the OSCAL Catalog. See the complete XML reference for model requirements."
               pending="[dev]"/>
   <x:scenario label="10.2.2 Requirements and Guidance for JSON Output | The final Catalog output, if using JSON, MUST be valid as defined by the JSON model documentation for the OSCAL Catalog. See the complete JSON reference for model requirements."
               pending="[dev]"/>
   <x:scenario label="10.2.3 Requirements and Guidance for YAML Output | The final Catalog output, if using YAML, MUST be valid as defined by the JSON model documentation for the OSCAL Catalog."
               pending="[dev]"/>
   <x:scenario label="10.2.4 Order of objects in serialization | When the output format is XML, tools MUST use the OSCAL canonical order as described above. When using the YAML or JSON formats, order conveys no meaning, and is not considered important."
               pending="[dev]"/>
</x:description>
